// 더 엄격한 타입지정 가능
// kim or park라는 문자만 들어올 수 있습니다 > literal types
// 123 이라는 숫자만 들어올 수 있음
var 이름 = 123;
// 이름 이라는 문자만 들어올 수 있음
var 이름2;
// 이런 식으로 union 타입도 가능한듯
var me = 123;
var 접니다;
// 함수에도 사용가능함 > 파라미터 자리에 무조건 'hello'만 들어올 수 있음
// 리턴은 1과 0만 할 수 있다.
function 함수(a) {
    return 1;
}
함수("hello");
// 응용1.
// 조건1 : 가위 바위 보 중 1개 입력가능
// 조건2 : 가위 바위 보 만 들어올 수 있는 array를 return 해야함
function 가위바위보(a) {
    return ["바위"];
}
가위바위보("가위");
// const 변수의 한계
// const 변수는 변하지 않는 값을 저장을 할 수 있다.
// kim이라는 변수는 무조건 'kim'이어야만 한다.
// const 변수는 2개 이상 지정하지 못함 > literal과의 차이점
// 둘다 변하지 않는 값을 저장한다는 것은 공통점이다.
var kim = "kim";
var 자료 = {
    name: "kim",
};
자료.name; // "kim"
function 내함수(a) { }
// 자료.name은 "kim"이다.
// 내함수의 파라미터에 "kim"을 넣어준거나 마찬가지인데 왜 오류가 날까?
// ** 내함수(자료.name) **
// kim이라는 타입이 들어올 수 있는 것이다.
// kim이라는 자료가 들어올 수 있다는 것이 아니다.
// 이를 해결하고 싶다면
// 1.  object를 만들 때 타입 지정을 확실히 한다.
var 자료수정 = {
    name: "kim",
};
내함수(자료수정.name);
// 타입을 "kim"이라 줬더니 오류 안나옴
// 2. as 문법으로 타입을 거짓말 친다.(비추천)
내함수(자료.name);
// 3. as const라는 키워드를 쓰기
var 자료수정2 = {
    name: "kim",
};
// as const를 붙히면 속성의 값을 타입으로 그대로 지정해준다.
// object 속성들에 모두 readonly를 붙여준 것 같은 효과
// object 자료를 완전히 잠가놓는 것
내함수(자료수정2.name);
